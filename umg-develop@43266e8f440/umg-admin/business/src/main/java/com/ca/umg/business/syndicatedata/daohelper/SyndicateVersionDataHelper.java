package com.ca.umg.business.syndicatedata.daohelper;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import com.ca.umg.business.constants.BusinessConstants;
import com.ca.umg.business.syndicatedata.entity.SyndicateData;
import com.ca.umg.business.syndicatedata.info.ColumnNames;
import com.ca.umg.business.syndicatedata.info.SyndicateDataColumnInfo;
import com.ca.umg.business.syndicatedata.info.SyndicateDataContainerInfo;
import com.ca.umg.business.syndicatedata.info.SyndicateDataKeyColumnInfo;
import com.ca.umg.business.syndicatedata.info.SyndicateDataKeyInfo;
import com.ca.umg.business.syndicatedata.util.ColumnDataTypes;
import com.ca.umg.business.syndicatedata.util.SyndicateUtil;

/**
 * 
 * @author repvenk
 * 
 *         Helper class to generate queries for creating syndicate data tables and indexes.
 * 
 */
@Service
public class SyndicateVersionDataHelper {

    private static final Logger LOGGER = LoggerFactory.getLogger(SyndicateVersionDataHelper.class);

    /**
     * Generates SQL statement to create table.
     * 
     * @param containerInfo
     * @return
     */
    public String createTableQuery(String containerName, List<SyndicateDataColumnInfo> metaData) {
        StringBuilder tableQuery = new StringBuilder(BusinessConstants.NUMBER_ONE_HUNDRED);
        tableQuery.append("CREATE TABLE ").append(StringUtils.upperCase(containerName)).append('(');
        tableQuery.append(ColumnNames.SYND_VER_ID.getName()).append(" INTEGER, ");
        for (SyndicateDataColumnInfo columnInfo : metaData) {
            tableQuery.append(columnInfo.getDisplayName()).append(' ');
            tableQuery.append(getDataType(columnInfo.getColumnType(), columnInfo.getColumnSize(), columnInfo.getPrecision()));
            tableQuery.append(columnInfo.isMandatory() ? " NOT NULL" : "");
            tableQuery.append(StringUtils.isNotEmpty(columnInfo.getDescription()) ? StringUtils.join(" COMMENT '",
                    columnInfo.getDescription(), "'") : "");
            tableQuery.append(',');
        }
        tableQuery.setCharAt(tableQuery.length() - 1, ' ');
        tableQuery.append(");");
        LOGGER.debug("Table creation query generated is {}", tableQuery.toString());
        return tableQuery.toString();
    }

    /**
     * Generates data type syntax for table creation.
     * 
     * @param dataType
     * @param columnSize
     * @return
     */
    private String getDataType(String dataType, int columnSize, int precission) {
        String dataTypeDDL = null;
        switch (dataType.toUpperCase(Locale.getDefault())) {
        case "NUMBER":
        case "INTEGER":
            dataTypeDDL = "INTEGER";
            break;
        case "VARCHAR":
        case "STRING":
            dataTypeDDL = "VARCHAR(" + columnSize + ')';
            break;
        case "DATETIME":
            dataTypeDDL = "DATETIME";
            break;
        case "DATE":
            dataTypeDDL = "DATE";
            break;
        case "DOUBLE":
        case "DECIMAL":
            dataTypeDDL = "DECIMAL(" + (columnSize + precission) + "," + precission + ")";
            break;
        case "BOOLEAN":
            dataTypeDDL = "TINYINT(1)";
            break;
        default:
            break;
        }
        return dataTypeDDL;
    }

    /**
     * Generates SQL statement to create indexes. No names are provided for the index. On execution of this query index names are
     * auto generated by the Database.
     * 
     * @param containerInfo
     * @return
     */
    public String createIndexesQuery(String containerName, List<SyndicateDataKeyInfo> dataKeyInfos) {
        StringBuilder indexesQuery = new StringBuilder(BusinessConstants.NUMBER_FIFTY);
        for (SyndicateDataKeyInfo keyDef : dataKeyInfos) {
            indexesQuery.append("CREATE INDEX ").append(keyDef.getKeyName()).append(" ON ").append(containerName).append('(');
            for (SyndicateDataKeyColumnInfo keyColumnInfo : keyDef.getsColumnInfos()) {
                if (keyColumnInfo.isStatus()) {
                    indexesQuery.append(keyColumnInfo.getColumnName()).append(',');
                }
            }
            indexesQuery.setCharAt(indexesQuery.length() - 1, ' ');
            indexesQuery.append(");");
        }
        return indexesQuery.toString();
    }

    /**
     * Generates SQL statements to insert data loaded for version.
     * 
     * @param containerInfo
     * @return
     */
    public String[] insertDataStatements(SyndicateDataContainerInfo containerInfo, SyndicateData syndicateData) {
        List<String> keys = null;
        List<String> queries = new ArrayList<>();
        StringBuilder query = null;
        Map<String, String> fieldMap = null;

        List<SyndicateDataColumnInfo> columnInfos = containerInfo.getMetaData();
        Map<String, ColumnDataTypes> columnDef = getColumnDataTypes(columnInfos);
        Map<String, String> fliedDispalyNameMap = getFliedDispalyNameMap(columnInfos);

        for (Map<String, String> map : containerInfo.getSyndicateVersionData()) {
            keys = new ArrayList<>();
            fieldMap = new HashMap<>();
            query = new StringBuilder(BusinessConstants.NUMBER_ONE_HUNDRED);
            if (CollectionUtils.isEmpty(keys)) {
                for (Map.Entry<String, String> entry : map.entrySet()) {
                    //UMG-4459 start
                    String key = SyndicateUtil.formatSyndicateColumnName(entry.getKey());
                    keys.add(fliedDispalyNameMap.get(key.toUpperCase(Locale.getDefault())));
                    fieldMap.put(fliedDispalyNameMap.get(key.toUpperCase(Locale.getDefault())), entry.getValue());
                    // UMG-4459 end
                }
            }
            query.append("INSERT INTO ").append(syndicateData.getTableName()).append('(')
                    .append(ColumnNames.SYND_VER_ID.getName()).append(',');
            query.append(StringUtils.join(keys, ","));
            query.append(") VALUES(").append(String.valueOf(syndicateData.getVersionId())).append(',');
            buildInsertStatement(keys, query, columnDef, fieldMap);
            query.setCharAt(query.length() - 1, ' ');
            query.append(");");
            queries.add(query.toString());
        }
        return queries.toArray(new String[queries.size()]);
    }

    private void buildInsertStatement(List<String> keys, StringBuilder query, Map<String, ColumnDataTypes> columnDef,
            Map<String, String> map) {
        for (String key : keys) {
            createQueryForDataTypes(query, columnDef, map, key);
            query.append(',');
        }
    }

    private void createQueryForDataTypes(StringBuilder query, Map<String, ColumnDataTypes> columnDef, Map<String, String> map,
            String key) {
        String value = null;
        switch (columnDef.get(key)) {
        case NUMBER:
        case INTEGER:
        case DOUBLE:
            value = map.get(key);
            query.append(StringUtils.isEmpty(value) ? "null" : value);
            break;
        case VARCHAR:
        case STRING:
            query.append('\'').append(map.get(key)).append('\'');
            break;
        case DATE:
            this.getDateType(map.get(key), query, "','%d-%b-%Y')");
            break;
        case DATETIME:
            this.getDateType(map.get(key), query, "','%b-%d-%Y %H:%i:%s')");
            break;
        case BOOLEAN:
            query.append(this.getBooleanValue(map.get(key)));
            break;
        default:
            break;
        }
    }

    private void getDateType(String keyValue, StringBuilder query, String formatter) {
        if (StringUtils.isEmpty(keyValue)) {
            query.append("null");
        } else {
            query.append("STR_TO_DATE('").append(keyValue).append(formatter);
        }

    }

    private String getBooleanValue(String string) {
        String value = "0";
        if (StringUtils.isNotEmpty(string) && string.equalsIgnoreCase("true")) {
            value = "1";
        }
        return value;
    }

    private Map<String, ColumnDataTypes> getColumnDataTypes(List<SyndicateDataColumnInfo> columnInfos) {
        Map<String, ColumnDataTypes> columnDef = new HashMap<>();
        for (SyndicateDataColumnInfo syndicateDataColumnInfo : columnInfos) {
            columnDef.put(syndicateDataColumnInfo.getDisplayName().toUpperCase(Locale.getDefault()),
                    ColumnDataTypes.valueOf(syndicateDataColumnInfo.getColumnType().toUpperCase(Locale.getDefault())));
        }
        return columnDef;
    }

    private Map<String, String> getFliedDispalyNameMap(List<SyndicateDataColumnInfo> columnInfos) {
        Map<String, String> nameDisplayMap = new HashMap<>();
        for (SyndicateDataColumnInfo syndicateDataColumnInfo : columnInfos) {
            //UMG-4459 start
            String field = SyndicateUtil.formatSyndicateColumnName(syndicateDataColumnInfo.getField());
            String displayName = SyndicateUtil.formatSyndicateColumnName(syndicateDataColumnInfo.getDisplayName());
            nameDisplayMap.put(field.toUpperCase(Locale.getDefault()), displayName.toUpperCase(Locale.getDefault()));
            // UMG-4459 end
        }
        return nameDisplayMap;
    }

    /**
     * 
     * @param tableName
     * @param keysInfo
     * @return
     */
    public List<String> dropIndexesQueries(String tableName, Set<String> keysInfo) {
        StringBuilder indexesQuery = null;
        List<String> dropQueries = new ArrayList<>();
        for (String keyName : keysInfo) {
            indexesQuery = new StringBuilder(BusinessConstants.NUMBER_FIFTY);
            indexesQuery.append("DROP INDEX ").append(tableName).append('_').append(keyName).append(" ON ").append(tableName)
                    .append(';');
            dropQueries.add(indexesQuery.toString());
        }
        return dropQueries;
    }
}
